# Chunk 4
cor(cost_report$cost_charge_ratio, cost_report$patient_revenue_per_bed)
# Chunk 5
cost_charge_ratio_model1 <- lm(cost_charge_ratio ~ patient_revenue_per_bed,
cost_report)
summary(cost_charge_ratio_model1)
# Chunk 6
tibble(pred = cost_charge_ratio_model1$fitted.values,
obs = cost_report$cost_charge_ratio) |>
ggplot(aes(x = pred, y = obs)) +
geom_point()
# Chunk 7
tibble(pred = cost_charge_ratio_model1$fitted.values,
obs = cost_report$cost_charge_ratio) |>
cor()
# Chunk 8
tibble(residual = cost_charge_ratio_model1$residuals,
patient_revenue_per_bed = cost_report$patient_revenue_per_bed) |>
ggplot(aes(x = patient_revenue_per_bed, y = residual)) +
geom_point()
# Chunk 9
cost_charge_ratio_model2 <-
lm(cost_charge_ratio ~ patient_revenue_per_bed + discharges_per_bed +
employees_per_bed + salary_per_bed +
patient_income_per_bed + patient_charges_per_bed +
hospital_state,
cost_report)
summary(cost_charge_ratio_model2)
# Chunk 10
tibble(pred = cost_charge_ratio_model2$fitted.values,
obs = cost_report$cost_charge_ratio) |>
ggplot(aes(x = pred, y = obs)) +
geom_point()
# Chunk 11
tibble(pred = cost_charge_ratio_model2$fitted.values,
obs = cost_report$cost_charge_ratio) |>
cor()
# Chunk 12
tibble(residual = cost_charge_ratio_model2$residuals,
patient_revenue_per_bed = cost_report$patient_revenue_per_bed) |>
ggplot(aes(x = patient_revenue_per_bed, y = residual)) +
geom_point()
summary(cost_charge_ratio_model2)
round(coef(cost_charge_ratio_model2)["patient_revenue_per_bed"], 3)
cost_charge_ratio_model2$coefficients["patient_revenue_per_bed"]
cost_charge_ratio_model2 <-
lm(cost_charge_ratio ~ patient_revenue_per_bed + discharges_per_bed +
employees_per_bed + salary_per_bed +
patient_income_per_bed + patient_charges_per_bed,
cost_report)
summary(cost_charge_ratio_model2)
cost_report
cost_report |> count(facility_type)
library(tidyverse)
hospital_data <- read_csv("hospital_data/CostReport_2021_Final.csv")
setwd("~/Library/CloudStorage/Box-Box/teaching/headlamp/statistics/assessments/project_prep")
library(tidyverse)
hospital_data <- read_csv("hospital_data/CostReport_2021_Final.csv")
colnames(hospital_data)
hospital_data_clean <- hospital_data |>
select(hospital_name = `Hospital Name`,
hospital_address = `Street Address`,
hospital_city = `City`,
hospital_state = `State Code`,
hospital_zip = `Zip Code`,
hospital_county = `County`,
rural_urban = `Rural Versus Urban`,
facility_type = `CCN Facility Type`,
full_time_employees = `FTE - Employees on Payroll`,
total_salary = `Total Salaries From Worksheet A`,
beds = `Number of Beds`,
discharges = `Total Discharges (V + XVIII + XIX + Unknown)`,
patient_charges = `Combined Outpatient + Inpatient Total Charges`,
patient_revenue = `Total Patient Revenue`,
income_patient_service = `Net Income from Service to Patients`,
cost_charge_ratio = `Cost To Charge Ratio`) |>
filter(!(hospital_state %in% c("AS", "PR", "GU", "VI", "DC")),
cost_charge_ratio < 10,
facility_type == "STH") |>
select(-facility_type)
set.seed(8328)
hospital_data_sample <- hospital_data_clean |>
drop_na(discharges, full_time_employees, beds, total_salary, patient_revenue, patient_charges) |>
sample_n(500)
write_csv(hospital_data_sample, "hospital_cost_report.csv")
summary(lm(cost_charge_ratio ~ rural_urban +
discharges +
full_time_employees + discharges,
hospital_data_sample))
urban <- hospital_data_sample |>
filter(rural_urban == "R") |>
mutate(discharges_per_bed = discharges / beds) |>
pull(discharges_per_bed)
rural <- hospital_data_sample |>
filter(rural_urban == "U") |>
mutate(discharges_per_bed = discharges / beds) |>
pull(discharges_per_bed)
mean(urban)
mean(rural)
t.test(urban, rural)
urban <- hospital_data_sample |>
filter(rural_urban == "R") |>
mutate(discharges_per_bed = full_time_employees / beds) |>
pull(discharges_per_bed)
rural <- hospital_data_sample |>
filter(rural_urban == "U") |>
mutate(discharges_per_bed = full_time_employees / beds) |>
pull(discharges_per_bed)
mean(urban)
mean(rural, na.rm = T)
t.test(urban, rural)
urban <- hospital_data_sample |>
filter(rural_urban == "R") |>
mutate(discharges_per_bed = patient_charges / patient_revenue) |>
pull(discharges_per_bed)
rural <- hospital_data_sample |>
filter(rural_urban == "U") |>
mutate(discharges_per_bed = patient_charges / patient_revenue) |>
pull(discharges_per_bed)
mean(urban, na.rm = T)
mean(rural, na.rm = T)
t.test(urban, rural)
cost_report <- read_csv("hospital_cost_report.csv")
mean(cost_report$cost_charge_ratio)
cost_report |>
ggplot() +
geom_histogram(aes(x = cost_charge_ratio))
cost_report |>
ggplot() +
geom_histogram(aes(x = cost_charge_ratio),
col = "white") +
geom_vline(xintercept = 1)
cost_report |>
filter(cost_charge_ratio < 0.1)
cost_report |>
filter(cost_charge_ratio < 0.01)
cost_report |>
filter(cost_charge_ratio < 0.05)
cost_report |>
filter(cost_charge_ratio < 0.05) |>
select(hospital_name, hospital_city, hospital_state)
cost_report |>
filter(cost_charge_ratio == max(cost_charge_ratio)) |>
select(hospital_name, hospital_city, hospital_state)
cost_report |>
filter(cost_charge_ratio == min(cost_charge_ratio)) |>
select(hospital_name, hospital_city, hospital_state)
hospital_Data
hospital_data
sd(hospital_data$`Cost To Charge Ratio`)
sd(hospital_data$`Cost To Charge Ratio`, na.rm = T)
mean(hospital_data$`Cost To Charge Ratio`, na.rm = T)
median(hospital_data$`Cost To Charge Ratio`, na.rm = T)
mean(cost_report$cost_charge_ratio)
sd(hospital_data$`Cost To Charge Ratio`, na.rm = T)
hospital_data_clean <- hospital_data |>
select(hospital_name = `Hospital Name`,
hospital_address = `Street Address`,
hospital_city = `City`,
hospital_state = `State Code`,
hospital_zip = `Zip Code`,
hospital_county = `County`,
rural_urban = `Rural Versus Urban`,
facility_type = `CCN Facility Type`,
full_time_employees = `FTE - Employees on Payroll`,
total_salary = `Total Salaries From Worksheet A`,
beds = `Number of Beds`,
discharges = `Total Discharges (V + XVIII + XIX + Unknown)`,
patient_charges = `Combined Outpatient + Inpatient Total Charges`,
patient_revenue = `Total Patient Revenue`,
income_patient_service = `Net Income from Service to Patients`,
cost_charge_ratio = `Cost To Charge Ratio`) |>
filter(!(hospital_state %in% c("AS", "PR", "GU", "VI", "DC")),
cost_charge_ratio < 10,
facility_type == "STH") |>
select(-facility_type)
mean(hospital_data_clean$cost_charge_ratio)
sd(hospital_data_clean$cost_charge_ratio)
mean(cost_report$cost_charge_ratio)
sd(cost_report$cost_charge_ratio)
simulated_means <- rnorm(1000, 0.26, 0.15 / sqrt(500))
n <- nrow(cost_report)
pop_mean <- 0.26
pop_sd <- 0.15
n <- nrow(cost_report)
simulated_means <- rnorm(1000, pop_mean, pop_sd / sqrt(n))
ggplot() +
geom_histogram(aes(x = simulated_means))
simulated_means <- rnorm(1000, mean = pop_mean, sd = pop_sd / sqrt(n))
ggplot() +
geom_histogram(aes(x = simulated_means))
# Chunk 1
# define a function called `add_one()` that adds 1 to its argument, x
add_one <- function(x) {
x + 1
}
# Chunk 2
# apply function add_one() to 5
add_one(5)
# Chunk 3
# apply function add_one() to 5 using a *named argument*
add_one(x = 5)
# Chunk 4
# re-define add_one() with two lines of code: x - 1 and x + 1
add_one <- function(x) {
x - 1
x + 1
}
# Chunk 5
# apply add_one to 5 again
add_one(5)
# Chunk 6
# redefine add_one() but apply the return statement to x - 1 only
add_one <- function(x) {
return(x - 1)
x + 1
}
# Chunk 7
# apply add_one to 5 again
add_one(5)
# Chunk 9
# define function cube()
cube <- function(value) {
cubed_value = value^3
return(cubed_value)
}
# apply cube() to 3
cube(value = 3)
add_xy()
add_xy
add_x2y
# Chunk 1
# define a function called `add_one()` that adds 1 to its argument, x
add_one <- function(x) {
x + 1
}
# Chunk 2
# apply function add_one() to 5
add_one(5)
# Chunk 3
# apply function add_one() to 5 using a *named argument*
add_one(x = 5)
# Chunk 4
# re-define add_one() with two lines of code: x - 1 and x + 1
add_one <- function(x) {
x - 1
x + 1
}
# Chunk 5
# apply add_one to 5 again
add_one(5)
# Chunk 6
# redefine add_one() but apply the return statement to x - 1 only
add_one <- function(x) {
return(x - 1)
x + 1
}
# Chunk 7
# apply add_one to 5 again
add_one(5)
# Chunk 9
# define function cube()
cube <- function(value) {
cubed_value = value^3
return(cubed_value)
}
# Chunk 10
# apply cube() to 3
cube(value = 3)
# Chunk 11
# define a function called add_x2y that computes x + 2y
add_x2y <- function(x, y) {
x + 2*y
}
# Chunk 12
# apply add_x2y() to x = 2 and y = 5
add_xy(2, 5)
add_x2y
# Chunk 1
# define a function called `add_one()` that adds 1 to its argument, x
add_one <- function(x) {
x + 1
}
# Chunk 2
# apply function add_one() to 5
add_one(5)
# Chunk 3
# apply function add_one() to 5 using a *named argument*
add_one(x = 5)
# Chunk 4
# re-define add_one() with two lines of code: x - 1 and x + 1
add_one <- function(x) {
x - 1
x + 1
}
# Chunk 5
# apply add_one to 5 again
add_one(5)
# Chunk 6
# redefine add_one() but apply the return statement to x - 1 only
add_one <- function(x) {
return(x - 1)
x + 1
}
# Chunk 7
# apply add_one to 5 again
add_one(5)
# Chunk 9
# define function cube()
cube <- function(value) {
cubed_value = value^3
return(cubed_value)
}
# Chunk 10
# apply cube() to 3
cube(value = 3)
# Chunk 11
# define a function called add_x2y that computes x + 2y
add_x2y <- function(x, y) {
x + 2*y
}
# Chunk 12
# apply add_x2y() to x = 2 and y = 5
add_x2y(2, 5)
# Chunk 13
add_x2y(y = 2, 5)
# Chunk 14
# run add_x2y() with named arguments x = 2 and y = 5
add_x2y(x = 2, y = 5)
# Chunk 15
# run add_x2y() with named arguments y = 5 and x = 2
add_x2y(y = 5, x = 2)
# Chunk 16
#| error: true
y
add_x2y <- function(x = 1, y = 1, output_type = c("numeric", "character")) {
# this line will set the default value of output_type to be "numeric"
# and will only allow options provided in the default vector
output_type <- match.arg(output_type)
# stop condition if x or y are not numeric
if (!is.numeric(x) | !is.numeric(y)) {
stop("'x' and 'y' must be numeric")
}
# computing my result
result <- x + 2 * y
# returning result in the format specified by output_type
if (output_type == "numeric") {
return(result)
} else if (output_type == "character") {
return(as.character(result))
}
}
# apply add_x2y() to x = 2 and y = 3 and output_type = "character"
add_x2y(x = 2, y = 3, output_type = "character")
# apply add_x2y() to x = 2 and y = 3 with no output_type specified
add_x2y(2, 3)
#| error: true
add_x2y(2, 3, output_type = "charcter")
#| error: true
add_x2y(2, 3, output_type = "blah")
# apply add_x2y() to x = 2 and y = 3 and output_type = "logical"
#| error: true
add_x2y(2, 3, output_type = "logical")
?geom_point
# load in the tidyverse and demographics NHANES data
library(tidyverse)
demographics <- read_csv("data/demographics.csv")
setwd("~/Library/CloudStorage/Box-Box/teaching/live_workshops_utah/2024-10-29-adv_r/website/content/complete")
# load in the tidyverse and demographics NHANES data
library(tidyverse)
demographics <- read_csv("data/demographics.csv")
setwd("~/Library/CloudStorage/Box-Box/teaching/live_workshops_utah/2024-10-29-adv_r/website/content/complete")
demographics <- read_csv("data/demographics.csv")
# take a look at the demographics data
head(demographics)
# compute boxplots for the age_years distribution across different levels of the served_active_duty_us variable
demographics |> ggplot() +
geom_boxplot(aes(x = served_active_duty_us,
y = age_years))
# compute boxplots for the age_years distribution across different levels of the served_active_duty_us variable
demographics |> ggplot() +
geom_boxplot(aes(x = served_active_duty_us,
y = age_years), na.rm = TRUE)
# turn the above boxplot code into a function called createBoxplots()
createBoxplots <- function(variable_name) {
demographics |> ggplot() +
geom_boxplot(aes(x = variable_name,
y = age_years))
}
# try to apply createBoxplots to the language_english column of demographics
createBoxplots(language_english)
createBoxplots("language_english")
# update our createBoxplots() function so that it uses tidy_evaluation
createBoxplots <- function(variable_name) {
demographics |> ggplot() +
geom_boxplot(aes(x = {{ variable_name }},
y = age_years))
}
createBoxplots(language_english)
# apply createBoxplots() to the marital_status column
createBoxplots(marital_status)
View(demographics)
createBoxplots(pregnant)
createBoxplots(marital_status) +
theme(axis.text.x = element_text(angle = 90,
hjust = 1,
vjust = 0.5))
library(patchwork)
createBoxplots(language_english) + createBoxplots(marital_status)
(createBoxplots(language_english) + createBoxplots(marital_status)) / createBoxplots(pregnant)
(createBoxplots(language_english) + createBoxplots(pregnant)) /   createBoxplots(marital_status)
createOrderedBars <- function(variable_name) {
demographics |>
# group by the column provided
group_by({{ variable_name }}) |>
# compute the mean age
summarize(mean_age = mean(age_years)) |>
# create the bar plot
ggplot() +
geom_col(aes(x = {{ variable_name }},
y = mean_age))
}
createOrderedBars(marital_status)
demographics |>
# group by the column provided
group_by(marital_status) |>
# compute the mean age
summarize(mean_age = mean(age_years))
demographics |>
group_by(marital_status) |>
summarize(mean_age = mean(age_years)) |>
ggplot() +
geom_col()
demographics |>
group_by(marital_status) |>
summarize(mean_age = mean(age_years)) |>
ggplot() +
geom_col(aes(x = marital_status,
y = mean_age))
createOrderedBars <- function(variable_name, ascending = TRUE) {
mean_age <- demographics |>
# group by the column provided
group_by({{ variable_name }}) |>
# compute the mean age
summarize(mean_age = mean(age_years))
if (ascending) {
mean_age <- mean_age |>
# arrange in increasing order of mean_age
arrange(mean_age) |>
# modify selected_variable so that it is a factor whose levels are in
# increasing order of mean_age
mutate(selected_variable = fct_inorder({{ variable_name }}))
}
# create the bar plot
mean_age |>
ggplot() +
geom_col(aes(x = selected_variable,
y = mean_age))
}
createOrderedBars(marital_status)
createOrderedBars(marital_status, ascending = TRUE)
createOrderedBars(marital_status, ascending = FALSE)
createOrderedBars <- function(variable_name, ascending = TRUE) {
mean_age <- demographics |>
# group by the column provided
group_by({{ variable_name }}) |>
# compute the mean age
summarize(mean_age = mean(age_years))
if (ascending) {
mean_age <- mean_age |>
# arrange in increasing order of mean_age
arrange(mean_age) |>
# modify selected_variable so that it is a factor whose levels are in
# increasing order of mean_age
mutate(selected_variable = fct_inorder({{ variable_name }}))
} else {
mean_age <- mean_age |>
mutate(selected_variable = variable_name)
}
# create the bar plot
mean_age |>
ggplot() +
geom_col(aes(x = selected_variable,
y = mean_age))
}
createOrderedBars(marital_status, ascending = FALSE)
createOrderedBars <- function(variable_name, ascending = TRUE) {
mean_age <- demographics |>
# group by the column provided
group_by({{ variable_name }}) |>
# compute the mean age
summarize(mean_age = mean(age_years))
if (ascending) {
mean_age <- mean_age |>
# arrange in increasing order of mean_age
arrange(mean_age) |>
# modify selected_variable so that it is a factor whose levels are in
# increasing order of mean_age
mutate(selected_variable = fct_inorder({{ variable_name }}))
} else {
mean_age <- mean_age |>
mutate(selected_variable = {{ variable_name }})
}
# create the bar plot
mean_age |>
ggplot() +
geom_col(aes(x = selected_variable,
y = mean_age))
}
createOrderedBars(marital_status, ascending = TRUE)
createOrderedBars(marital_status, ascending = FALSE)
createOrderedBars(marital_status)
