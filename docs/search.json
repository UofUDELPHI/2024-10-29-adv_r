[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advanced R for Data Analysis",
    "section": "",
    "text": "Registration: Use the following link to sign up for this workshop.\nSign up for the DELPHI mailing list to stay in the loop about future workshops and funding opportunities."
  },
  {
    "objectID": "index.html#general-information",
    "href": "index.html#general-information",
    "title": "Advanced R for Data Analysis",
    "section": "General Information",
    "text": "General Information\nWhat: This workshop will build upon the foundations covered in the Introduction to R workshop, and will introduce more advanced tools, including creating your own custom functions, iterating with purrr map functions, advanced data manipulations with dplyr, and reshaping and joining datasets in R.\nWho: The course is aimed at graduate students, postdocs, staff, faculty, and other researchers across campus who are interested in taking their R skills to the next level to learn how to conduct more sophisticated data manipulations and analysis.\nParticipants in this workshop should already be comfortable working in Quarto (or R Markdown) documents in RStudio, and have basic knowledge of the the R programming language and the tidyverse, including the dplyr select, filter, mutate, and summarize functions, as well as creating basic visualizations using ggplot2.\nRequirements: Participants must bring a laptop onto which they can download R and Rstudio (and you should do so before the workshop).\nContact: Please email andrew.george@hsc.utah.edu or rebecca.barter@hsc.utah.edu for more information."
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "Advanced R for Data Analysis",
    "section": "Schedule",
    "text": "Schedule\nNote that the schedule below serves as a guideline. The start, end, and break times are fixed, but timing for each topics covered may vary as we may go faster or slower through the content.\n\n\n\nTime\nTopic\n\n\n\n\n9:00\nIntroduction and Setup\n\n\n9:30\nWriting Functions\n\n\n10:30\n[Break]\n\n\n10:45\nIteration with Purrr\n\n\n12:00\n[Lunch]\n\n\n1:00\nAcross()\n\n\n1:45\nRecoding variables\n\n\n2:30\n[Break]\n\n\n2:45\nReshaping Data\n\n\n3:15\nJoining Data\n\n\n4:00\n[End]"
  },
  {
    "objectID": "content/complete/01_custom_functions_complete.html",
    "href": "content/complete/01_custom_functions_complete.html",
    "title": "Custom functions",
    "section": "",
    "text": "In this notebook, you will learn how to define your own functions.\n\n# define a function called `add_one()` that adds 1 to its argument, x\nadd_one &lt;- function(x) {\n  x + 1\n}\n\nThe code that is run when you “call” your function is inside the curly parentheses.\n\n# apply function add_one() to 5\nadd_one(5)\n\n[1] 6\n\n\n\n# apply function add_one() to 5 using a *named argument*\nadd_one(x = 5)\n\n[1] 6\n\n\nWhat happens when the body of your function contains two pieces of code?\n\n# re-define add_one() with two lines of code: x - 1 and x + 1\nadd_one &lt;- function(x) {\n  x - 1\n  x + 1\n}\n\n\n# apply add_one to 5 again\nadd_one(5)\n\n[1] 6\n\n\nBy default, any custom R function you create will automatically return the final result that is computed.\nFor this reason, it is common to explicitly provide a “return statement”.\n\n# redefine add_one() but apply the return statement to x - 1 only\nadd_one &lt;- function(x) {\n  return(x - 1)\n  x + 1\n}\n\n\n# apply add_one to 5 again\nadd_one(5)\n\n[1] 4"
  },
  {
    "objectID": "content/complete/01_custom_functions_complete.html#a-simple-custom-function",
    "href": "content/complete/01_custom_functions_complete.html#a-simple-custom-function",
    "title": "Custom functions",
    "section": "",
    "text": "In this notebook, you will learn how to define your own functions.\n\n# define a function called `add_one()` that adds 1 to its argument, x\nadd_one &lt;- function(x) {\n  x + 1\n}\n\nThe code that is run when you “call” your function is inside the curly parentheses.\n\n# apply function add_one() to 5\nadd_one(5)\n\n[1] 6\n\n\n\n# apply function add_one() to 5 using a *named argument*\nadd_one(x = 5)\n\n[1] 6\n\n\nWhat happens when the body of your function contains two pieces of code?\n\n# re-define add_one() with two lines of code: x - 1 and x + 1\nadd_one &lt;- function(x) {\n  x - 1\n  x + 1\n}\n\n\n# apply add_one to 5 again\nadd_one(5)\n\n[1] 6\n\n\nBy default, any custom R function you create will automatically return the final result that is computed.\nFor this reason, it is common to explicitly provide a “return statement”.\n\n# redefine add_one() but apply the return statement to x - 1 only\nadd_one &lt;- function(x) {\n  return(x - 1)\n  x + 1\n}\n\n\n# apply add_one to 5 again\nadd_one(5)\n\n[1] 4"
  },
  {
    "objectID": "content/complete/01_custom_functions_complete.html#the-general-syntax-of-a-custom-function",
    "href": "content/complete/01_custom_functions_complete.html#the-general-syntax-of-a-custom-function",
    "title": "Custom functions",
    "section": "The general syntax of a custom function",
    "text": "The general syntax of a custom function\nThe general syntax of a custom function is shown below:\n\nfn_name &lt;- function(arg) {\n  # code involving arg\n  \n  return(object)\n}"
  },
  {
    "objectID": "content/complete/01_custom_functions_complete.html#exercise",
    "href": "content/complete/01_custom_functions_complete.html#exercise",
    "title": "Custom functions",
    "section": "Exercise",
    "text": "Exercise\nWrite a function called “cube” that returns the cubic (^3) of the argument\n\n# define function cube()\ncube &lt;- function(value) {\n  cubed_value = value^3\n  return(cubed_value)\n}\n\n\n# apply cube() to 3\ncube(value = 3)\n\n[1] 27"
  },
  {
    "objectID": "content/complete/01_custom_functions_complete.html#multiple-arguments",
    "href": "content/complete/01_custom_functions_complete.html#multiple-arguments",
    "title": "Custom functions",
    "section": "Multiple arguments",
    "text": "Multiple arguments\nTo create a function with multiple arguments, you need to provide two arguments inside the function definition, separated by a comma. The function below has two arguments: x and y:\n\n# define a function called add_x2y that computes x + 2y\nadd_x2y &lt;- function(x, y) {\n  x + 2*y\n}\n\nWhen you call this add_x2y(), you can then specify a value for each argument, separated by a comma:\n\n# apply add_x2y() to x = 2 and y = 5\nadd_x2y(2, 5)\n\n[1] 12\n\n\nWhen you have multiple arguments, funny things can start to happen when you don’t name your arguments.\nWhat do you think will happen if you first provide a named argument for the second argument y by specifying y = 2, and then provide an unnamed argument afterwards?\n\nadd_x2y(y = 2, 5)\n\n[1] 9\n\n\nR will be clever and it will first apply the named arguments by assigning y to the value 2, and then fill in the remaining argument, so x will be assigned to the value 5.\nIt is good practice to name your arguments if there is any chance for ambiguity.\n\n# run add_x2y() with named arguments x = 2 and y = 5\nadd_x2y(x = 2, y = 5)\n\n[1] 12\n\n\nNote that when you provide named arguments, it technically doesn’t matter which order you provide them in (but this is not true when you don’t provide named arguments!)\n\n# run add_x2y() with named arguments y = 5 and x = 2\nadd_x2y(y = 5, x = 2)\n\n[1] 12\n\n\nAgain, note that even when you provide named arguments in a function call (e.g., in add_x2y(x = 2, y = 5)), you are not defining a global version of the arguments, i.e., there is no y defined:\n\ny\n\nError in eval(expr, envir, enclos): object 'y' not found\n\n\nWhat do you think will happen when you call add_x2y without any parentheses?\n\n# run add_x2y\nadd_x2y\n\nfunction(x, y) {\n  x + 2*y\n}\n&lt;bytecode: 0x12902b270&gt;\n\n\nIt will print out the definition of the function!\nWhat do you think will happen when you call add_x2y with parentheses but no arguments?\n\nadd_x2y()\n\nError in add_x2y(): argument \"x\" is missing, with no default\n\n\nYou get an error! We can fix this by providing “default” values for the arguments.\n\nDefault values\nTo provide default values for your arguments, you can assign the argument inside the function definition. In the example below, both x and y are given the default values of 1.\n\n# redefine add_x2y() with default values for x and y (both 1)\nadd_x2y &lt;- function(x = 1, y = 1) {\n  x + 2*y\n}\n\n\n# call add_x2y() without any arguments\nadd_x2y()\n\n[1] 3\n\n\nWhat happens if we only provide some of the arguments?\n\n# run add_x2y() with a single unnamed argument, 4\nadd_x2y(4)\n\n[1] 6\n\n\n\n# run add_x2y() with a single argument: y = 3\nadd_x2y(y = 3)\n\n[1] 7\n\n\n\n\nExercise\nWithout using the mean() function, write a function called my_mean() that takes four values as its arguments and computes their mean. Ensure that each argument has a default of 0. Use your function to compute the mean of the values 4, 5, 2, 1.\nHow would you modify your function to take a single vector of length 4 as its argument instead of four separate arguments?\n\nSolution\n\nmy_mean &lt;- function(a = 0, b = 0, c = 0, d = 0) {\n  return((a + b + c + d) / 4)\n}\n\nNote that when we run this function it is taking four separate arguments (rather than a vector, as the original mean function does):\n\nmy_mean(4, 5, 2, 1)\n\n[1] 3\n\n\nYou can define a function that instead takes a single vector as its argument:\n\nmy_mean_vec &lt;- function(vec) {\n  return(sum(vec) / length(vec))\n}\n\nand then to run this function, you provide a vector by wrapping the four values inside c():\n\nmy_mean_vec(c(4, 5, 2, 1))\n\n[1] 3\n\n\nWhat happens if you apply your original my_mean() function to this vector?\n\nmy_mean(c(4, 5, 2, 1))\n\n[1] 1.00 1.25 0.50 0.25\n\n\nThis is equivalent to assigning the argument a = c(4, 5, 2, 1), and then not providing any values for the b, c, and d arguments (so their default values are used). So the above code is equivalent to:\n\n# (a + b + c + d) / 4\n\n(c(4, 5, 2, 1) + 0 + 0 + 0) / 4\n\n[1] 1.00 1.25 0.50 0.25\n\n\nThe fact that we haven’t told any of our functions what type of object the arguments should be means that the function will simply take whatever object it is given and try and run the code."
  },
  {
    "objectID": "content/complete/01_custom_functions_complete.html#ifelse-statements",
    "href": "content/complete/01_custom_functions_complete.html#ifelse-statements",
    "title": "Custom functions",
    "section": "If/else statements",
    "text": "If/else statements\n\nIf statements\nThe following code defines a variable a, and then runs some conditional code that is only run if the condition a == 1 is TRUE.\n\n# define a variable a containing 5\na &lt;- 5\n# if a is equal to 1, print out some text\nif (a == 1) {\n  \"a is 1\"\n}\n\n# Then:\n# 1. try the code again, with a equal to 1\n# 2. replace the code that is run in the if statement with a mathematical computation\n# 3. replace the code that is run in the if statement with a variable definition (e.g., define y &lt;- 3)\n\na &lt;- 1\n# if a is equal to 1, print out some text\nif (a == 1) {\n  y &lt;- 3\n}\n\nUnlike for a function, if you define a variable inside an if statement, then this variable will have been defined in our “global” environment too.\n\n# Does y exist globally?\ny\n\n\n\nElse statemenets\nThe “else” part of the “if/else” statement provides some code that will be run if the “if” condition is not TRUE.\n\n# define a variable \"a\" containing 3\na &lt;- 3\n# if \"a\" equals 1, define y &lt;- 3, else define y &lt;- 9\nif (a == 1) {\n  y &lt;- 3\n} else {\n  y &lt;- 9\n}\n\n\n# check what y was assigned to\ny\n\n[1] 9\n\n\n\n\nUsing “if” statements to provide custom errors for a function\nThe following uses an “if” statement to add a “stop condition” that throws an error when innapropriate arguments are provided\n\n# add an \"if\" condition to throw an error if `a` is either non-numeric OR the length of `a` is greater than 1\nmy_mean &lt;- function(a = 0, b = 0, c = 0, d = 0) {\n  # write your if statement here containing a stop() function\n  if (!is.numeric(a) | (length(a) != 1)) {\n    stop(\"'a' must be a numeric value of length 1\")\n  }\n  return((a + b + c + d) / 4)\n}\n\n\n\nExercise\n\nWrite a standalone if/else statement that checks whether the value in a variable called age is at least 18. If the age variable is 18 or older, your statement should return the character value of “You are eligible to vote” and if not, your statement should return “You are not eligible to vote”\n\n\nage &lt;- 21\nif (age &gt;= 18) {\n  \"You are eligible to vote\"\n} else {\n  \"You are not eligible to vote\"\n}\n\n[1] \"You are eligible to vote\"\n\n\n\nWrite a function that computes the area of a circle (area = pi * radius^2) with the radius as its argument, and throws an error if a non-numeric or a negative radius value is given.\n\n\ncircle_area &lt;- function(radius) {\n  if (!is.numeric(radius) | radius &lt; 0) {\n    stop(\"'radius' must be a non-negative numeric value\")\n  }\n  area &lt;- pi * radius^2\n  return(area)\n}\n\nTest your function on the following code\n\n# the following should throw an error:\ncircle_area(\"4\")\n\nError in circle_area(\"4\"): 'radius' must be a non-negative numeric value\n\ncircle_area(-4)\n\nError in circle_area(-4): 'radius' must be a non-negative numeric value\n\n# the following should NOT throw an error:\ncircle_area(4)\n\n[1] 50.26548"
  },
  {
    "objectID": "content/complete/01_custom_functions_complete.html#default-argument-options-with-match.arg",
    "href": "content/complete/01_custom_functions_complete.html#default-argument-options-with-match.arg",
    "title": "Custom functions",
    "section": "Default argument options with match.arg()",
    "text": "Default argument options with match.arg()\nBelow, we give an example of providing multiple options to an argument.\n\n# define a function add_x2y with three arguments:\n# x: a numeric value with default value 1\n# y: a numeric value with default value 1\n# output_type: a character value with default value \"numeric\" and alternative option \"character\"\n\n# in the body of the function:\n# use match.arg() to ensure that output_type is one of the options provided\n# use an if statement to modify the output based on the value of output_type\n\n\nadd_x2y &lt;- function(x = 1, y = 1, output_type = c(\"numeric\", \"character\")) {\n  # this line will set the default value of output_type to be \"numeric\"\n  # and will only allow options provided in the default vector\n  output_type &lt;- match.arg(output_type)\n  \n  # stop condition if x or y are not numeric\n  if (!is.numeric(x) | !is.numeric(y)) {\n    stop(\"'x' and 'y' must be numeric\")\n  }\n  \n  # computing my result\n  result &lt;- x + 2 * y\n  \n  # returning result in the format specified by output_type\n  if (output_type == \"numeric\") {\n    return(result)\n  } else if (output_type == \"character\") {\n    return(as.character(result))\n  }\n  \n}\n\n\n# apply add_x2y() to x = 2 and y = 3 and output_type = \"character\"\nadd_x2y(x = 2, y = 3, output_type = \"character\")\n\n[1] \"8\"\n\n\n\n# apply add_x2y() to x = 2 and y = 3 with no output_type specified\nadd_x2y(2, 3)\n\n[1] 8\n\n\n\n# apply add_x2y() to x = 2 and y = 3 and output_type = \"logical\" \nadd_x2y(2, 3, output_type = \"logical\")\n\nError in match.arg(output_type): 'arg' should be one of \"numeric\", \"character\"\n\n\n\nExercise\nWrite a function called calculate_area() that will calculate the area of the shape specified in the argument shape, which has options “circle”, “square”, and “triangle”. Your function will need to have the following additional arguments:\n\nradius for computing the area of a circle (pi * radius^2),\nside for computing the area of a square (side^2),\nbase and height for computing the area of a triangle (height * base / 2).\n\nArguments that are not always required should have a default value of NULL. Your function should throw an error when you fail any value other than “circle”, “square” or “triangle” for the shape argument (you can use match.arg() to do this!).\nYour function should throw an error when:\n\nthe ‘radius’ argument is not provided when shape == \"circle\"\nthe ‘side’ argument is not provided when shape == \"square\"\nthe ‘base’ and ‘height’ arguments are not provided when shape == \"triangle\"\n\n\ncalculate_area &lt;- function(shape = c(\"circle\", \"square\", \"triangle\"),\n                           radius = NULL,\n                           side = NULL,\n                           base = NULL,\n                           height = NULL) {\n  \n  shape = match.arg(shape)\n  # error statements\n  if (shape == \"circle\" & is.na(radius)) {\n    stop(\"'radius' required for 'circle' shape\")\n  } \n  if (shape == \"square\" & is.na(side)) {\n    stop(\"'side' required for 'square' shape\")\n  }\n  if (shape == \"triangle\" & (is.na(base) | is.na(height))) {\n    stop(\"'base' and 'height' required for 'triangle' shape\")\n  }\n  \n  # compute the area\n  if (shape == \"circle\") {\n    area &lt;- pi * radius^2\n  } else if (shape == \"square\") {\n    area &lt;- side^2\n  } else if (shape == \"triangle\") {\n    area &lt;- base * height / 2\n  }\n  \n  return(area)\n  \n}"
  },
  {
    "objectID": "content/complete/01_custom_functions_complete.html#tidy-evaluation-for-writing-tidyverse-style-functions",
    "href": "content/complete/01_custom_functions_complete.html#tidy-evaluation-for-writing-tidyverse-style-functions",
    "title": "Custom functions",
    "section": "Tidy evaluation for writing tidyverse-style functions",
    "text": "Tidy evaluation for writing tidyverse-style functions\nSometimes you want to write a function whose argument is a column of a data frame without quotes (i.e., in the tidyverse style) so that you can use it in a tidyverse function.\n\n# load in the tidyverse and demographics NHANES data\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ndemographics &lt;- read_csv(\"data/demographics.csv\")\n\nRows: 10175 Columns: 19\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): interview_examination, gender, race, marital_status, pregnant\ndbl (9): respondent_id, age_years, age_months_sc_0_2yr, six_month_period, ag...\nlgl (5): served_active_duty_us, served_active_duty_foreign, born_usa, citize...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n# take a look at the demographics data\nhead(demographics)\n\n# A tibble: 6 × 19\n  respondent_id interview_examination gender age_years age_months_sc_0_2yr race \n          &lt;dbl&gt; &lt;chr&gt;                 &lt;chr&gt;      &lt;dbl&gt;               &lt;dbl&gt; &lt;chr&gt;\n1         73557 both interview and e… male          69                  NA black\n2         73558 both interview and e… male          54                  NA white\n3         73559 both interview and e… male          72                  NA white\n4         73560 both interview and e… male           9                  NA white\n5         73561 both interview and e… female        73                  NA white\n6         73562 both interview and e… male          56                  NA mexi…\n# ℹ 13 more variables: six_month_period &lt;dbl&gt;, age_months_ex_0_19yr &lt;dbl&gt;,\n#   served_active_duty_us &lt;lgl&gt;, served_active_duty_foreign &lt;lgl&gt;,\n#   born_usa &lt;lgl&gt;, citizen_usa &lt;lgl&gt;, time_in_us &lt;dbl&gt;, education_youth &lt;dbl&gt;,\n#   education &lt;dbl&gt;, marital_status &lt;chr&gt;, pregnant &lt;chr&gt;,\n#   language_english &lt;lgl&gt;, household_income &lt;dbl&gt;\n\n\nNotice that when we refer to the variables from our data frame in the context of the tidyverse (including ggplot2), we do not use quotes around the column names:\n\n# compute boxplots for the age_years distribution across different levels of the language_english variable\ndemographics |&gt; ggplot() +\n  geom_boxplot(aes(x = language_english,\n                   y = age_years))\n\n\n\n\n\n\n\n\nLet’s try and turn this into a function so we can create boxplots comparing the age distribution across all of the levels of other categorical variables without having to copy-and-paste the code over and over again.\nIn this first attempt, we use variable_name as the argument:\n\n# turn the above boxplot code into a function called createBoxplots()\ncreateBoxplots &lt;- function(variable_name) {\n  \n  demographics |&gt; ggplot() +\n    geom_boxplot(aes(x = variable_name,\n                     y = age_years)) \n  \n}\n\n\n# try to apply createBoxplots() to the language_english column \ncreateBoxplots(language_english)\n\nError in `geom_boxplot()`:\n! Problem while computing aesthetics.\nℹ Error occurred in the 1st layer.\nCaused by error:\n! object 'language_english' not found\n\ncreateBoxplots(\"language_english\")\n\n\n\n\n\n\n\n\nThe issue is that ggplot wants us to refer to the column names without strings, but our custom function doesn’t know how to find our column name variable that we provide.\nWe can use tidy evaluation ({ var_name }) to solve this problem.\n\n# update our createBoxplots() function so that it uses tidy_evaluation\ncreateBoxplots &lt;- function(variable_name) {\n  demographics |&gt; ggplot() +\n    geom_boxplot(aes(x = {{ variable_name }},\n                     y = age_years)) \n}\n\nAnd now it works:\n\n# apply createBoxplots() to the language_english column\ncreateBoxplots(language_english)\n\n\n\n\n\n\n\n\nLet’s use our function on a few different columns to make sure:\n\n# apply createBoxplots() to the marital_status column\ncreateBoxplots(marital_status)\n\n\n\n\n\n\n\n# apply createBoxplots() to the pregnant column\ncreateBoxplots(pregnant)\n\n\n\n\n\n\n\n\n\nTip: Using patchwork to patch together plots\nThe patchwork library can be used to create custom grids of ggplot objects (be sure to expand your plot window if the plots aren’t showing up properly):\n\n# load the patchwork library\nlibrary(patchwork)\n# create a grid of the language_english and marital_status boxplots\ncreateBoxplots(language_english) + createBoxplots(marital_status)\n\n\n\n\n\n\n\n\n\n# create a grid of the language_english and pregnant boxplots \n# on top with the marital_status boxplots underneath\n(createBoxplots(language_english) + createBoxplots(pregnant)) /   createBoxplots(marital_status)\n\n\n\n\n\n\n\n\n\n\nExercise\nCreate a function called createOrderedBars() that takes a categorical column from demographics as its argument and creates a bar chart for the average age for each level of the variable.\nHint: Some example code for computing the average age for each level of the marital_status variable and creating a bar chart is shown below:\n\ndemographics |&gt; \n  group_by(marital_status) |&gt;\n  summarize(mean_age = mean(age_years)) |&gt;\n  ggplot() +\n  geom_col(aes(x = marital_status, \n               y = mean_age))\n\n\n\n\n\n\n\n\nChallenge activity: Arrange the bars in ascending order, and provide an argument called ascending that allows the user to specify whether or not the bars will be arranged in ascending order.\n\nSolution\nNote that you’ll want to use geom_col() instead of geom_bar() to create bar charts where the bars have the specific height provided in the y-variable.\n\ncreateOrderedBars &lt;- function(variable_name) {\n  demographics |&gt; \n    # group by the column provided\n    group_by({{ variable_name }}) |&gt;\n    # compute the mean age\n    summarize(mean_age = mean(age_years)) |&gt;\n    # create the bar plot\n    ggplot() +\n    geom_col(aes(x = {{ variable_name }}, \n                 y = mean_age))\n}\n\n\ncreateOrderedBars(marital_status)\n\n\n\n\n\n\n\n\n\n\nChallenge solution\nTo arrange the bars in ascending order of mean_age, you first need to convert the categorical variable itself to a factor whose levels are in the order that you want the bars to appear. You can do this by arranging the rows of your data frame in order of mean_age and then using fct_inorder() to convert your variable to a factor with levels match the increasing order of mean_age.\n\ncreateOrderedBars &lt;- function(variable_name, ascending = TRUE) {  \n  mean_age &lt;- demographics |&gt; \n    # group by the column provided\n    group_by({{ variable_name }}) |&gt;\n    # compute the mean age\n    summarize(mean_age = mean(age_years))\n  \n  if (ascending) {\n    mean_age &lt;- mean_age |&gt;\n      # arrange in increasing order of mean_age \n      arrange(mean_age) |&gt;\n      # modify selected_variable so that it is a factor whose levels are in \n      # increasing order of mean_age  \n      mutate(selected_variable = fct_inorder({{ variable_name }})) \n  } else {\n    mean_age &lt;- mean_age |&gt;\n      mutate(selected_variable = {{ variable_name }}) \n  }\n  \n  # create the bar plot\n  mean_age |&gt;\n    ggplot() +\n    geom_col(aes(x = selected_variable, \n                 y = mean_age))\n}\n\n\ncreateOrderedBars(marital_status, ascending = TRUE)\n\n\n\n\n\n\n\ncreateOrderedBars(marital_status, ascending = FALSE)\n\n\n\n\n\n\n\ncreateOrderedBars(marital_status)"
  },
  {
    "objectID": "content/incomplete/02_iteration_purrr.html",
    "href": "content/incomplete/02_iteration_purrr.html",
    "title": "Iteration with purrr",
    "section": "",
    "text": "The purpose of this lesson is to learn how to iteratively apply functions to all elements contained within an object, such as all columns in a data frame, or all entries in a vector.\nThe “purrr” R package that we will be using in this lesson is included in the tidyverse package.\n# load the tidyverse and demographics dataset\nThe function that we want to iterate first is the n_distinct() function from the tidyverse.\nRecall that to pull up the help page for a function, you can use the following syntax:\n# pull up the help page for n_distinct\nn_distinct() counts the number of unique values in a vector.\n# apply n_distinct to the \"gender\" column of demographics\nThe code below uses the map() function to apply n_distinct() to every column of the demographics data frame simultaneously:\n# use map() to apply n_distinct to every column of demographics\nThe output of the map() function is a list (more on that in a moment).\nThe following code shows a simpler example, this time applying the exp() function to all entries/elements in a simple numeric vector:\n# use map() to apply exp() to the vector c(4, 5, 6)"
  },
  {
    "objectID": "content/incomplete/02_iteration_purrr.html#using-custom-functions-in-purrr",
    "href": "content/incomplete/02_iteration_purrr.html#using-custom-functions-in-purrr",
    "title": "Iteration with purrr",
    "section": "Using custom functions in purrr",
    "text": "Using custom functions in purrr\nTo iterate using your own custom functions in a purrr map() function, you can define your function and provide it in the second argument of map().\n\n# define a function called exp_plus_one() that returns exp(x) + 1\n\n# apply it to every entry in the vector c(1, 4, 5)\n\nFor simple functions like this, we can define the function inside the map() function itself:\n\n# apply the function exp(x) + 1 to every entry in the vector c(1, 4, 5)\n# using an \"anonymous\" function\n\nHowever, we can go one step further and forego the function(x) part entirely using what I call the “tilde-dot” shorthand syntax.\nHere, we use the tilde ~ symbol to “start” an anonymous function and we use a . to represent the argument of our anonymous function.\n\n# apply the function exp(x) + 1 to every entry in the vector c(1, 4, 5)\n# using the \"tilde-dot\" syntax\n\nTo decide what should go inside the ~{}, I typically use a representative value to test out my code first.\nLet’s count the number of missing values in each column of demographics.\nFor example, below, I take a single column demographics$pregnant, and I write out the code that I want to apply to it:\n\n# compute the number of missing values in the \"pregnant\" column of demographics\n\nGeneralize this code for the map function:\n\n# use a map function to compute the number of missing values in every column\n\n\nExercise\nUse the tilde-dot short-hand syntax to compute the number of values in each column that is equal to 1. Recall that if a vector has missing values, and you want to use sum(), you will want to provide an argument na.rm = TRUE to ignore missing values."
  },
  {
    "objectID": "content/incomplete/02_iteration_purrr.html#alternative-map-functions-for-outputting-doubles-characters-and-data-frames",
    "href": "content/incomplete/02_iteration_purrr.html#alternative-map-functions-for-outputting-doubles-characters-and-data-frames",
    "title": "Iteration with purrr",
    "section": "Alternative map functions for outputting doubles, characters and data frames",
    "text": "Alternative map functions for outputting doubles, characters and data frames\nRecall our map() function previously that we used to count the number of missing values in each column of the demographics data.\n\nmap(demographics, ~sum(is.na(.)))\n\nA list may not be the most useful format for this information…\n\nOutputting numeric vectors\nThe map_dbl() function will output a “double” (numeric) vector.\n\n# use map_dbl to count the number of missing values in each column and\n# output a numeric vector\n\n\n\nOutputting character vectors\nThe map_chr() function can output a character vector.\n\n# use map_chr to apply class to every column and output a character vector\n\n\n\nOutputting data frames\nOne of the most versatile functions is the map_df() function, which outputs a data frame.\n\n# apply map_df to demographics to determine the class of each column, outputting a \"wide\" data frame\n\nIf you want your output to be in a “long” format, the function you are applying must output a single-column tibble/data frame.\n\n# use tibble() to create a single-column tibble containing the class of demographics$pregnant\n\n# modify this code to be the function call in map_df to create a \n# long-form data frame\n\n# provide an .id argument to include the original column names as a variable\n\n\n\nExample\nThis long-format is very useful if you want to create a plot, such as a bar chart for the number of missing values.\n\n# create a bar chart of the number of missing values in each column\n# use factors to order the columns by the number of missing values\n\nAn alternative approach is to map_df() is to use map_dbl() and enframe()\n\n# use map_dbl() and enframe() to create a long data frame of the \n# number of missing values in each column"
  },
  {
    "objectID": "content/incomplete/01_custom_functions.html",
    "href": "content/incomplete/01_custom_functions.html",
    "title": "Custom functions",
    "section": "",
    "text": "In this notebook, you will learn how to define your own functions.\n\n# define a function called `add_one()` that adds 1 to its argument, x\n\nThe code that is run when you “call” your function is inside the curly parentheses.\n\n# apply function add_one() to 5\n\n\n# apply function add_one() to 5 using a *named argument*\n\nWhat happens when the body of your function contains two pieces of code?\n\n# re-define add_one() with two lines of code: x - 1 and x + 1\n\n\n# apply add_one to 5 again\n\nBy default, any custom R function you create will automatically return the final result that is computed.\nFor this reason, it is common to explicitly provide a “return statement”.\n\n# redefine add_one() but apply the return statement to x - 1 only\n\n\n# apply add_one to 5 again"
  },
  {
    "objectID": "content/incomplete/01_custom_functions.html#a-simple-custom-function",
    "href": "content/incomplete/01_custom_functions.html#a-simple-custom-function",
    "title": "Custom functions",
    "section": "",
    "text": "In this notebook, you will learn how to define your own functions.\n\n# define a function called `add_one()` that adds 1 to its argument, x\n\nThe code that is run when you “call” your function is inside the curly parentheses.\n\n# apply function add_one() to 5\n\n\n# apply function add_one() to 5 using a *named argument*\n\nWhat happens when the body of your function contains two pieces of code?\n\n# re-define add_one() with two lines of code: x - 1 and x + 1\n\n\n# apply add_one to 5 again\n\nBy default, any custom R function you create will automatically return the final result that is computed.\nFor this reason, it is common to explicitly provide a “return statement”.\n\n# redefine add_one() but apply the return statement to x - 1 only\n\n\n# apply add_one to 5 again"
  },
  {
    "objectID": "content/incomplete/01_custom_functions.html#the-general-syntax-of-a-custom-function",
    "href": "content/incomplete/01_custom_functions.html#the-general-syntax-of-a-custom-function",
    "title": "Custom functions",
    "section": "The general syntax of a custom function",
    "text": "The general syntax of a custom function\nThe general syntax of a custom function is shown below:\n\nfn_name &lt;- function(arg) {\n  # code involving arg\n  \n  return(object)\n}"
  },
  {
    "objectID": "content/incomplete/01_custom_functions.html#exercise",
    "href": "content/incomplete/01_custom_functions.html#exercise",
    "title": "Custom functions",
    "section": "Exercise",
    "text": "Exercise\nWrite a function called “cube” that returns the cubic (^3) of the argument\n\n# define function cube()\n\n\n# apply cube() to 3"
  },
  {
    "objectID": "content/incomplete/01_custom_functions.html#multiple-arguments",
    "href": "content/incomplete/01_custom_functions.html#multiple-arguments",
    "title": "Custom functions",
    "section": "Multiple arguments",
    "text": "Multiple arguments\nTo create a function with multiple arguments, you need to provide two arguments inside the function definition, separated by a comma. The function below has two arguments: x and y:\n\n# define a function called add_x2y that computes x + 2y\n\nWhen you call this add_x2y(), you can then specify a value for each argument, separated by a comma:\n\n# apply add_x2y() to x = 2 and y = 5\n\nWhen you have multiple arguments, funny things can start to happen when you don’t name your arguments.\nWhat do you think will happen if you first provide a named argument for the second argument y by specifying y = 2, and then provide an unnamed argument afterwards?\n\nadd_x2y(y = 2, 5)\n\nError in add_x2y(y = 2, 5): could not find function \"add_x2y\"\n\n\nR will be clever and it will first apply the named arguments by assigning y to the value 2, and then fill in the remaining argument, so x will be assigned to the value 5.\nIt is good practice to name your arguments if there is any chance for ambiguity.\n\n# run add_x2y() with named arguments x = 2 and y = 5\n\nNote that when you provide named arguments, it technically doesn’t matter which order you provide them in (but this is not true when you don’t provide named arguments!)\n\n# run add_x2y() with named arguments y = 5 and x = 2\n\nAgain, note that even when you provide named arguments in a function call (e.g., in add_x2y(x = 2, y = 5)), you are not defining a global version of the arguments, i.e., there is no y defined:\nWhat do you think will happen when you call add_x2y without any parentheses?\n\n# run add_x2y\n\nIt will print out the definition of the function!\nWhat do you think will happen when you call add_x2y with parentheses but no arguments?\n\n# run add_x2y()\n\nYou get an error! We can fix this by providing “default” values for the arguments.\n\nDefault values\nTo provide default values for your arguments, you can assign the argument inside the function definition. In the example below, both x and y are given the default values of 1.\n\n# redefine add_x2y() with default values for x and y (both 1)\n\n\n# call add_x2y() without any arguments\n\nWhat happens if we only provide some of the arguments?\n\n# run add_x2y() with a single unnamed argument, 4\n\n\n# run add_x2y() with a single argument: y = 3\n\n\n\nExercise\nWithout using the mean() function, write a function called my_mean() that takes four values as its arguments and computes their mean. Ensure that each argument has a default of 0. Use your function to compute the mean of the values 4, 5, 2, 1.\nHow would you modify your function to take a single vector of length 4 as its argument instead of four separate arguments?\n\nSolution"
  },
  {
    "objectID": "content/incomplete/01_custom_functions.html#ifelse-statements",
    "href": "content/incomplete/01_custom_functions.html#ifelse-statements",
    "title": "Custom functions",
    "section": "If/else statements",
    "text": "If/else statements\n\nIf statements\nThe following code defines a variable a, and then runs some conditional code that is only run if the condition a == 1 is TRUE.\n\n# define a variable `a` containing 5\n\n# if `a` is equal to 1, print out some text\n\n\n\n# Then:\n# 1. try the code again, with `a` equal to 1\n# 2. replace the code that is run in the if statement with a mathematical computation\n# 3. replace the code that is run in the if statement with a variable definition (e.g., define y &lt;- 3)\n\nUnlike for a function, if you define a variable inside an if statement, then this variable will have been defined in our “global” environment too.\n\n# Does y exist globally?\n\n\n\nElse statemenets\nThe “else” part of the “if/else” statement provides some code that will be run if the “if” condition is not TRUE.\n\n# define a variable \"a\" containing 3\n\n# if \"a\" equals 1, define y &lt;- 3, else define y &lt;- 9\n\n\n# check what y was assigned to\n\n\n\nUsing “if” statements to provide custom errors for a function\nThe following uses an “if” statement to add a “stop condition” that throws an error when innapropriate arguments are provided\n\n# add an \"if\" condition to `my_mean()` to throw an error if the \n# first argument `a` is either non-numeric OR \n# if the length of `a` is greater than 1\n\n\n\nExercise\n\nWrite a standalone if/else statement that checks whether the value in a variable called age is at least 18. If the age variable is 18 or older, your statement should return the character value of “You are eligible to vote” and if not, your statement should return “You are not eligible to vote”\n\n\nWrite a function, circle_area(), that computes the area of a circle (area = pi * radius^2) with the radius as its argument, and throws an error if a non-numeric or a negative radius value is given.\n\nTest your function on the following code\n\n# the following should throw an error:\ncircle_area(\"4\")\n\nError in circle_area(\"4\"): could not find function \"circle_area\"\n\ncircle_area(-4)\n\nError in circle_area(-4): could not find function \"circle_area\"\n\n# the following should NOT throw an error:\ncircle_area(4)\n\nError in circle_area(4): could not find function \"circle_area\""
  },
  {
    "objectID": "content/incomplete/01_custom_functions.html#default-argument-options-with-match.arg",
    "href": "content/incomplete/01_custom_functions.html#default-argument-options-with-match.arg",
    "title": "Custom functions",
    "section": "Default argument options with match.arg()",
    "text": "Default argument options with match.arg()\nBelow, we give an example of providing multiple options to an argument.\n\n# define a function add_x2y() with three arguments:\n# x: a numeric value with default value 1\n# y: a numeric value with default value 1\n# output_type: a character value with default value \"numeric\" and alternative option \"character\"\n\n# in the body of the function:\n# use match.arg() to ensure that output_type is one of the options provided\n# use an if statement to modify the output based on the value of output_type\n\n\n# apply add_x2y() to x = 2 and y = 3 and output_type = \"character\"\n\n\n# apply add_x2y() to x = 2 and y = 3 with no output_type specified\n\n\n# apply add_x2y() to x = 2 and y = 3 and output_type = \"logical\" \n\n\nExercise\nWrite a function called calculate_area() that will calculate the area of the shape specified in the argument shape, which has options “circle”, “square”, and “triangle”. Your function will need to have the following additional arguments:\n\nradius for computing the area of a circle (pi * radius^2),\nside for computing the area of a square (side^2),\nbase and height for computing the area of a triangle (height * base / 2).\n\nArguments that are not always required should have a default value of NULL. Your function should throw an error when you fail any value other than “circle”, “square” or “triangle” for the shape argument (you can use match.arg() to do this!).\nYour function should throw an error when:\n\nthe ‘radius’ argument is not provided when shape == \"circle\"\nthe ‘side’ argument is not provided when shape == \"square\"\nthe ‘base’ and ‘height’ arguments are not provided when shape == \"triangle\""
  },
  {
    "objectID": "content/incomplete/01_custom_functions.html#tidy-evaluation-for-writing-tidyverse-style-functions",
    "href": "content/incomplete/01_custom_functions.html#tidy-evaluation-for-writing-tidyverse-style-functions",
    "title": "Custom functions",
    "section": "Tidy evaluation for writing tidyverse-style functions",
    "text": "Tidy evaluation for writing tidyverse-style functions\nSometimes you want to write a function whose argument is a column of a data frame without quotes (i.e., in the tidyverse style) so that you can use it in a tidyverse function.\n\n# load in the tidyverse and demographics NHANES data\n\n\n# take a look at the demographics data\n\nNotice that when we refer to the variables from our data frame in the context of the tidyverse (including ggplot2), we do not use quotes around the column names:\n\n# Use ggplot2 to compute boxplots for the age_years distribution across \n# different levels of the language_english variable\n\nLet’s try and turn this into a function.\nIn this first attempt, we use variable_name as the argument:\n\n# turn the above boxplot code into a function called createBoxplots()\n\n\n# try to apply createBoxplots() to the language_english column \n\nThe issue is that ggplot wants us to refer to the column names without quotes, but our custom function doesn’t know how to find our column name variable that we provide.\nWe can use tidy evaluation ({ var_name }) to solve this problem.\n\n# update our createBoxplots() function so that it uses tidy_evaluation\n\nAnd now it works:\n\n# apply createBoxplots() to the language_english column\n\nLet’s use our function on a few different columns to make sure:\n\n# apply createBoxplots() to the marital_status column\n\n# apply createBoxplots() to the pregnant column\n\n\nTip: Using patchwork to patch together plots\nThe patchwork library can be used to create custom grids of ggplot objects (be sure to expand your plot window if the plots aren’t showing up properly):\n\n# load the patchwork library\n\n# create a grid of the language_english and marital_status boxplots\n\n\n# create a grid of the language_english and pregnant boxplots on top \n# with the marital_status boxplots underneath\n\n\n\nExercise\nCreate a function called createOrderedBars() that takes a categorical column from demographics as its argument and creates a bar chart for the average age for each level of the variable.\nHint: Some example code for computing the average age for each level of the marital_status variable and creating a bar chart is shown below:\n\ndemographics |&gt; \n  group_by(marital_status) |&gt;\n  summarize(mean_age = mean(age_years)) |&gt;\n  ggplot() +\n  geom_col(aes(x = marital_status, \n               y = mean_age))\n\nChallenge activity: Arrange the bars in ascending order, and provide an argument called ascending that allows the user to specify whether or not the bars will be arranged in ascending order.\n\nSolution\nNote that you’ll want to use geom_col() instead of geom_bar() to create bar charts where the bars have the specific height provided in the y-variable."
  },
  {
    "objectID": "content/incomplete/05_pivoting.html",
    "href": "content/incomplete/05_pivoting.html",
    "title": "Reshaping (Pivoting) Data",
    "section": "",
    "text": "In this lesson, we will be working with a new NHANES table that contains urine albumin and creatinine lab data.\n\n# load the tidyverse and the urine_albumin_creatinine NHANES data\n\n\n# take a look at the first 10 rows\n\nThis data is in a long format–there are multiple rows for each observational unit, each corresponding to a different variable being measured (in this case, the different labs).\nA wide format, on the other hand, will only have one row for each observational unit (respondent), and each of the individual variables being measured (the labs) will have their own column, each containing the values for the corresponding lab.\nYou can convert from a long format to a wide format using the pivor_wider() function.\nThe code below creates a wide-form version of the labs data, and saves it as a new data frame called labs_data_wide:\n\n# use pivot_wider() to convert the labs data from a \n# long format to a wide format. \n# arguments are `names_from` and `values_from`\n# save the wide data as `labs_data_wide`.\n\nIf you want to convert from a wide format dataset into a longer-format dataset, you can instead use the pivot_longer() function.\n\n# use pivot_longer() to convert labs_data_wide back to along format\n# arguments are `cols` (use a select helper!), `names_to` and `values_to`\n\nUse-case for long-format: creating a visualization that compares the different variables using ggplot2.\n\n# create boxplots using the long format for the measurements from each lab\n# maybe add a log-scale to the y-axis\n\n\nExercise\nLoad the demographics data and use select() to select just the respondent_id, gender, marital_status and race columns and then use pivot_longer() to create the following long-format table (below are just the first 10 rows).\nrespondent_id name value\n  \n1 73557 gender male\n2 73557 marital_status separated 3 73557 race black\n4 73558 gender male\n5 73558 marital_status married\n6 73558 race white\n7 73559 gender male\n8 73559 marital_status married\n9 73559 race white\n10 73560 gender male"
  },
  {
    "objectID": "content/incomplete/03_across.html",
    "href": "content/incomplete/03_across.html",
    "title": "Across",
    "section": "",
    "text": "In this lesson, we will introduce the across() function, which can be used to apply dplyr functions like mutate, summarize, select, etc to subsets of columns that satisfy certain criteria, such as to all numeric columns, or all columns that start with age_.\n# load the tidyverse and demographics dataset\nLet’s suppose that our task is to convert all character columns of the demographics data to upper-case.\n# apply toupper() to the string value \"abc\"\nBefore introducing across, let’s first see one way that we could do this using the map() functions that we have just learned:\n# create a copy of demographics\n\n# create a logical vector for identifying character columns using map_chr()\n\n# re-assign the character columns to an upper-case version of themselves \n# using map_df() applied to demographics_tmp[character_cols] with toupper()\n\n\n# look at demographics_tmp\n\n# look at demographics (it should still have lowercase)\nWhile this works, it is fairly convoluted, is hard to read, and involves defining an intermediate variable (character_cols) – in the tidyverse style, it is generally recommended to avoid defining intermediate variables whenever possible."
  },
  {
    "objectID": "content/incomplete/03_across.html#introducing-across",
    "href": "content/incomplete/03_across.html#introducing-across",
    "title": "Across",
    "section": "Introducing across()",
    "text": "Introducing across()\nWe could instead do this kind of operation using a mutate() operation in conjunction with across().\nLet’s figure out the code for just one column first\n\n# apply toupper to interview_examination with mutate\n\nTo do this for all character columns, you need to provide across() to the argument of your mutate function. The across() function has two arguments:\n\nThe first argument is a “select statement” that specifies which columns you want to apply your function to.\nThe second argument is the function name, toupper, that we want to apply to all columns that are selected as a result of the first argument.\n\nThe result is that toupper() is applied to all columns “where” is.character() would result in TRUE:\n\n# use across inside mutate to apply toupper() to all columns \n# where(is.character) is TRUE..."
  },
  {
    "objectID": "content/incomplete/03_across.html#more-across-examples",
    "href": "content/incomplete/03_across.html#more-across-examples",
    "title": "Across",
    "section": "More across examples",
    "text": "More across examples\n\nAdd 100 to all age_ columns\nIf we were to do this to just the age_years column, our code would look like:\n\n# use mutate to add 100 to age_years\n\nTo generalize this to all columns that start with age_ using across(), we can use the starts_with() select helper, and apply the anonymous function ~{. + 100}:\n\n# use across inside mutate to apply ~{. + 100} to all columns \n# that starts_with(\"age_\")...\n\n\n\nConvert born_usa and citizen_usa to numeric (binary) columns using ends_with()\n\n# take a look at born_usa and citizen_use using select()\n\n\n# use across inside mutate to apply as.numeric to all columns \n# that ends_with(\"_usa\")...\n\n\n\nConvert born_usa and citizen_usa to numeric (binary) columns using a vector of column names\nSuppose we had a vector of column names that we wanted to modify using mutate():\n\n# define a vector selected_columns with \"born_usa\" and \"citizen_usa\"\n\nThen we could use all_of(selected_cols) in across() to apply the function to all columns listed in the selected_cols vector as follows:\n\n# use across inside mutate to apply as.numeric to all_of(selected_columns)"
  },
  {
    "objectID": "content/incomplete/03_across.html#select-helpers-summary",
    "href": "content/incomplete/03_across.html#select-helpers-summary",
    "title": "Across",
    "section": "Select helpers summary",
    "text": "Select helpers summary\nSo far we have seen the following “select helpers” that can be used to specify the columns inside across():\n\nwhere() – across to all columns that satisfy a logical condition (across(where(is.character), fun))\nstarts_with() and ends_with() – across all columns that start or ends with a specified string (across(starts_with(\"abc\"), fun))\ncontains() – across all columns that contain a specified string (across(contains(\"abc\"), fun))\nall_of() and any_of() – across all columns whose names are contained in a character vector, where all_of() requires all columns in the vector be present. (across(all_of(vec_names), fun))\neverything() – across all columns\n\nThese can also be used within select()\n\n# select all columns that contain \"age\"\n\n# select all columns that start with \"age\"\n\n# select all columns that have a logical type\n\n\nExercise\n\nFor all columns that contain the word “education” (education_youth and education), add the number 5 to each value\nFor all numeric columns, standardize the values by subtracting the mean and dividing by the standard deviation\nCompute the average age across all columns that start with age_ (Hint: use across() within summarize())\nCompute the total number of TRUE values in the born_usa, citizen_usa, and language_english columns (Hint: use across() within summarize())"
  }
]